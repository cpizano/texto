// This is the plex precompiled header cc.
// Do not edit this file by hand.

#include "stdafx.h"



#pragma comment(lib, "dwrite.lib")
#pragma comment(lib, "shcore.lib")
#pragma comment(lib, "d2d1.lib")
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "dcomp.lib")
namespace plx {
plx::ComPtr<IDCompositionDesktopDevice> CreateDCoDevice2(
    plx::ComPtr<ID2D1Device> device2D) {
  plx::ComPtr<IDCompositionDesktopDevice> device;
  auto hr = DCompositionCreateDevice2(device2D.Get(),
                                      __uuidof(device),
                                      reinterpret_cast<void **>(device.GetAddressOf()));
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return device;
}
plx::ComPtr<IDCompositionSurface> CreateDCoSurface(
    plx::ComPtr<IDCompositionDesktopDevice> device, unsigned int w, unsigned int h) {
  plx::ComPtr<IDCompositionSurface> surface;
  auto hr = device->CreateSurface(w, h,
                                  DXGI_FORMAT_B8G8R8A8_UNORM,
                                  DXGI_ALPHA_MODE_PREMULTIPLIED,
                                  surface.GetAddressOf());
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return surface;
}
plx::ComPtr<IDCompositionVisual2> CreateDCoVisual(plx::ComPtr<IDCompositionDesktopDevice> device) {
  plx::ComPtr<IDCompositionVisual2> visual;
  auto hr = device->CreateVisual(visual.GetAddressOf());
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return visual;
}
plx::ComPtr<IDCompositionTarget> CreateDCoWindowTarget(
    plx::ComPtr<IDCompositionDesktopDevice> device, HWND window) {
  plx::ComPtr<IDCompositionTarget> target;
  auto hr = device->CreateTargetForHwnd(window, TRUE, target.GetAddressOf());
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return target;
}
plx::ComPtr<IDWriteFactory> CreateDWriteFactory() {
  plx::ComPtr<IDWriteFactory> factory;
  auto hr = ::DWriteCreateFactory(
      DWRITE_FACTORY_TYPE_SHARED,
      __uuidof(IDWriteFactory),
      reinterpret_cast<IUnknown**>(factory.GetAddressOf()));
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return factory;
}
plx::ComPtr<ID2D1Factory2> CreateD2D1FactoryST(D2D1_DEBUG_LEVEL debug_level) {
  D2D1_FACTORY_OPTIONS options = {};
  options.debugLevel = debug_level;

  plx::ComPtr<ID2D1Factory2> factory;
  auto hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED,
                              options,
                              factory.GetAddressOf());
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return factory;
}
plx::ComPtr<ID2D1Device> CreateDeviceD2D1(plx::ComPtr<ID3D11Device> device3D,
                                          plx::ComPtr<ID2D1Factory2> factoryD2D1) {
  plx::ComPtr<IDXGIDevice3> dxgi_dev;
  device3D.As(&dxgi_dev);
  plx::ComPtr<ID2D1Device> device2D;

  auto hr = factoryD2D1->CreateDevice(dxgi_dev.Get(),
                                      device2D.GetAddressOf());
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return device2D;
}
plx::ComPtr<ID3D11Device> CreateDeviceD3D11(int extra_flags) {
  auto flags = D3D11_CREATE_DEVICE_BGRA_SUPPORT |
               D3D11_CREATE_DEVICE_SINGLETHREADED;
  flags |= extra_flags;

  plx::ComPtr<ID3D11Device> device;
  auto hr = D3D11CreateDevice(nullptr,
                              D3D_DRIVER_TYPE_HARDWARE,
                              nullptr,
                              flags,
                              nullptr, 0,
                              D3D11_SDK_VERSION,
                              device.GetAddressOf(),
                              nullptr,
                              nullptr);
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return device;
}
plx::ComPtr<ID2D1DeviceContext> CreateDCoDeviceCtx(
    plx::ComPtr<IDCompositionSurface> surface,
    const plx::DPI& dpi, const D2D1_SIZE_F& extra_offset) {
  plx::ComPtr<ID2D1DeviceContext> dc;
  POINT offset;
  auto hr = surface->BeginDraw(nullptr,
                               __uuidof(dc),
                               reinterpret_cast<void **>(dc.GetAddressOf()),
                               &offset);
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  dc->SetDpi(float(dpi.get_dpi_x()), float(dpi.get_dpi_y()));
  auto matrix = D2D1::Matrix3x2F::Translation(
      dpi.to_logical_x(offset.x) + extra_offset.width,
      dpi.to_logical_y(offset.y) + extra_offset.height);
  dc->SetTransform(matrix);
  return dc;
}
ItRange<uint8_t*> RangeFromBytes(void* start, size_t count) {
  auto s = reinterpret_cast<uint8_t*>(start);
  return ItRange<uint8_t*>(s, s + count);
}
ItRange<const uint8_t*> RangeFromBytes(const void* start, size_t count) {
  auto s = reinterpret_cast<const uint8_t*>(start);
  return ItRange<const uint8_t*>(s, s + count);
}
ItRange<const uint8_t*> RangeFromString(const std::string& str) {
  auto s = reinterpret_cast<const uint8_t*>(&str.front());
  return ItRange<const uint8_t*>(s, s + str.size());
}
ItRange<uint8_t*> RangeFromString(std::string& str) {
  auto s = reinterpret_cast<uint8_t*>(&str.front());
  return ItRange<uint8_t*>(s, s + str.size());
}
ItRange<const uint16_t*> RangeFromString(const std::wstring& str) {
  auto s = reinterpret_cast<const uint16_t*>(&str.front());
  return ItRange<const uint16_t*>(s, s + str.size());
}
ItRange<uint16_t*> RangeFromString(std::wstring& str) {
  auto s = reinterpret_cast<uint16_t*>(&str.front());
  return ItRange<uint16_t*>(s, s + str.size());
}
plx::ComPtr<IDWriteTextFormat> CreateDWriteSystemTextFormat(
    plx::ComPtr<IDWriteFactory> dw_factory,
    const wchar_t* font_family, float size,
    const plx::FontWSSParams& params) {
  plx::ComPtr<IDWriteTextFormat> format;
  auto hr = dw_factory->CreateTextFormat(font_family, nullptr,
                                         params.weight, params.style, params.stretch,
                                         size, L"",
                                         format.GetAddressOf());
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return format;
}
plx::FilePath GetAppDataPath(bool roaming) {
  auto folder = roaming? FOLDERID_RoamingAppData : FOLDERID_LocalAppData;
  wchar_t* path = nullptr;
  auto hr = ::SHGetKnownFolderPath(folder, 0, nullptr, &path);
  if (hr != S_OK)
    throw plx::IOException(__LINE__, L"<appdata folder>");
  auto fp = FilePath(path);
  ::CoTaskMemFree(path);
  return fp;
}
char* HexASCII(uint8_t byte, char* out) {
  *out++ = HexASCIITable[(byte >> 4) & 0x0F];
  *out++ = HexASCIITable[byte & 0x0F];
  return out;
}
std::string HexASCIIStr(const plx::Range<const uint8_t>& r, char separator) {
  if (r.empty())
    return std::string();

  std::string str((r.size() * 3) - 1, separator);
  char* data = &str[0];
  for (size_t ix = 0; ix != r.size(); ++ix) {
    data = plx::HexASCII(r[ix], data);
    ++data;
  }
  return str;
}
short NextInt(char value) {
  return short(value);
}
int NextInt(short value) {
  return int(value);
}
long long NextInt(int value) {
  return long long(value);
}
long long NextInt(long value) {
  return long long(value);
}
long long NextInt(long long value) {
  return value;
}
short NextInt(unsigned char value) {
  return short(value);
}
int NextInt(unsigned short value) {
  return int(value);
}
long long NextInt(unsigned int value) {
  return long long(value);
}
long long NextInt(unsigned long value) {
  return long long(value);
}
long long NextInt(unsigned long long value) {
  if (static_cast<long long>(value) < 0LL)
    throw plx::OverflowException(__LINE__, plx::OverflowKind::Positive);
  return long long(value);
}
plx::ComPtr<IDWriteTextLayout> CreateDWTextLayout(
  plx::ComPtr<IDWriteFactory> dw_factory, plx::ComPtr<IDWriteTextFormat> format,
  const plx::Range<const wchar_t>& text, const D2D1_SIZE_F& size) {
  plx::ComPtr<IDWriteTextLayout> layout;
  auto hr = dw_factory->CreateTextLayout(
      text.start(), plx::To<UINT32>(text.size()),
      format.Get(),
      size.width, size.height,
      layout.GetAddressOf());
  if (hr != S_OK)
    throw plx::ComException(__LINE__, hr);
  return layout;
}
std::string DecodeString(plx::Range<const char>& range) {
  if (range.empty())
    return std::string();
  if (range[0] != '\"') {
    auto r = plx::RangeFromBytes(range.start(), 1);
    throw plx::CodecException(__LINE__, &r);
  }

  std::string s;
  for (;;) {
    auto text_start = range.start();
    while (range.advance(1) > 0) {
      auto c = range.front();
      if (c < 32) {
        throw plx::CodecException(__LINE__, nullptr);
      } else {
        switch (c) {
          case '\"' : break;
          case '\\' : goto escape;
          default: continue;
        }
      }
      s.append(++text_start, range.start());
      range.advance(1);
      return s;
    }
    // Reached the end of range before a (").
    throw plx::CodecException(__LINE__, nullptr);

  escape:
    s.append(++text_start, range.start());
    if (range.advance(1) <= 0)
      throw plx::CodecException(__LINE__, nullptr);

    switch (range.front()) {
      case '\"':  s.push_back('\"'); break;
      case '\\':  s.push_back('\\'); break;
      case '/':   s.push_back('/');  break;
      case 'b':   s.push_back('\b'); break;
      case 'f':   s.push_back('\f'); break;
      case 'n':   s.push_back('\n'); break;
      case 'r':   s.push_back('\r'); break;
      case 't':   s.push_back('\t'); break;   //$$ missing \u (unicode).
      default: {
        auto r = plx::RangeFromBytes(range.start() - 1, 2);
        throw plx::CodecException(__LINE__, &r);
      }
    }
  }
}
namespace JsonImp {
template <typename StrT>
bool Consume(plx::Range<const char>& r, StrT&& str) {
  auto c = r.starts_with(plx::RangeFromLitStr(str));
  if (c) {
    r.advance(c);
    return true;
  }
  else {
    return (c != 0);
  }
}

bool IsNumber(plx::Range<const char>&r) {
  if ((r.front() >= '0') && (r.front() <= '9'))
    return true;
  if ((r.front() == '-') || (r.front() == '+'))
    return true;
  if (r.front() == '.')
    return true;
  return false;
}

plx::JsonValue ParseArray(plx::Range<const char>& range) {
  if (range.empty())
    throw plx::CodecException(__LINE__, NULL);
  if (range.front() != '[')
    throw plx::CodecException(__LINE__, NULL);

  JsonValue value(plx::JsonType::ARRAY);
  range.advance(1);

  for (;!range.empty();) {
    range = plx::SkipWhitespace(range);

    if (range.front() == ',') {
      if (range.advance(1) <= 0)
        break;
      range = plx::SkipWhitespace(range);
    }

    if (range.front() == ']') {
      range.advance(1);
      return value;
    }

    value.push_back(ParseJsonValue(range));
  }

  auto r = plx::RangeFromBytes(range.start(), range.size());
  throw plx::CodecException(__LINE__, &r);
}

plx::JsonValue ParseNumber(plx::Range<const char>& range) {
  size_t pos = 0;
  auto num = plx::StringFromRange(range);

  auto iv = std::stoll(num, &pos);
  if ((range[pos] != 'e') && (range[pos] != 'E') && (range[pos] != '.')) {
    range.advance(pos);
    return iv;
  }

  auto dv = std::stod(num, &pos);
  range.advance(pos);
  return dv;
}

plx::JsonValue ParseObject(plx::Range<const char>& range) {
  if (range.empty())
    throw plx::CodecException(__LINE__, NULL);
  if (range.front() != '{')
    throw plx::CodecException(__LINE__, NULL);

  JsonValue obj(plx::JsonType::OBJECT);
  range.advance(1);

  for (;!range.empty();) {
    if (range.front() == '}') {
      range.advance(1);
      return obj;
    }

    range = plx::SkipWhitespace(range);
    auto key = plx::DecodeString(range);

    range = plx::SkipWhitespace(range);
    if (range.front() != ':')
      throw plx::CodecException(__LINE__, nullptr);
    if (range.advance(1) <= 0)
      throw plx::CodecException(__LINE__, nullptr);

    range = plx::SkipWhitespace(range);
    obj[key] = ParseJsonValue(range);

    range = plx::SkipWhitespace(range);
    if (range.front() == ',') {
      if (range.advance(1) <= 0)
        break;
      range = plx::SkipWhitespace(range);
    }
  }
  throw plx::CodecException(__LINE__, nullptr);
}

}
plx::JsonValue ParseJsonValue(plx::Range<const char>& range) {
  range = plx::SkipWhitespace(range);
  if (range.empty())
    throw plx::CodecException(__LINE__, NULL);

  if (range.front() == '{')
    return JsonImp::ParseObject(range);
  if (range.front() == '\"')
    return plx::DecodeString(range);
  if (range.front() == '[')
    return JsonImp::ParseArray(range);
  if (JsonImp::Consume(range, "true"))
    return true;
  if (JsonImp::Consume(range, "false"))
    return false;
  if (JsonImp::Consume(range, "null"))
    return nullptr;
  if (JsonImp::IsNumber(range))
    return JsonImp::ParseNumber(range);

  auto r = plx::RangeFromBytes(range.start(), range.size());
  throw plx::CodecException(__LINE__, &r);
}
plx::JsonValue JsonFromFile(plx::File& cfile) {
  if (!cfile.is_valid())
    throw plx::IOException(__LINE__, L"<json file>");
  auto size = cfile.size_in_bytes();
  plx::Range<uint8_t> r(0, plx::To<size_t>(size));
  auto mem = plx::HeapRange(r);
  if (cfile.read(r, 0) != size)
    throw plx::IOException(__LINE__, L"<json file>");
  plx::Range<const char> json(reinterpret_cast<char*>(r.start()),
                              reinterpret_cast<char*>(r.end()));
  return plx::ParseJsonValue(json);
}
std::wstring UTF16FromUTF8(const plx::Range<const uint8_t>& utf8) {
  if (utf8.empty())
      return std::wstring();
  // Get length and validate string.
  const int utf16_len = ::MultiByteToWideChar(
      CP_UTF8, MB_ERR_INVALID_CHARS,
      reinterpret_cast<const char*>(utf8.start()),
      plx::To<int>(utf8.size()),
      NULL,
      0);
  if (utf16_len == 0) {
    throw plx::CodecException(__LINE__, nullptr);
  }

  std::wstring utf16;
  utf16.resize(utf16_len);
  // Now do the conversion without validation.
  if (!::MultiByteToWideChar(
      CP_UTF8, 0,
      reinterpret_cast<const char*>(utf8.start()),
      plx::To<int>(utf8.size()),
      &utf16[0],
      utf16_len)) {
    throw plx::CodecException(__LINE__, nullptr);
  }
  return utf16;
}
std::string UTF8FromUTF16(const plx::Range<const uint16_t>& utf16) {
  if (utf16.empty())
      return std::string();
  // compute length.
  const int utf8_len = ::WideCharToMultiByte(
      CP_UTF8, 0,
      reinterpret_cast<const wchar_t*>(utf16.start()),
      plx::To<int>(utf16.size()),
      NULL,
      0,
      NULL, NULL);
  if (utf8_len == 0) {
    throw plx::CodecException(__LINE__, nullptr);
  }

  std::string utf8;
  utf8.resize(utf8_len);
  // now do the conversion.
  if (!::WideCharToMultiByte(
      CP_UTF8, 0,
      reinterpret_cast<const wchar_t*>(utf16.start()),
      plx::To<int>(utf16.size()),
      &utf8[0],
      utf8_len,
      NULL, NULL)) {
    throw plx::CodecException(__LINE__, nullptr);
  }
  return utf8;
}
}
